\begin{filecontents}{byrne-latex.bib}
@book{Byrne1847,
  author = {Byrne, Oliver},
  publisher = {William Pickering},
  title = {{The first six books of the elements of Euclid, in which coloured diagrams and symbols are used instead of letters for the greater ease of learners}},
  year = 1847
}
@book{Tufte90,
  author = {Tufte, Edward R.},
  isbn = {978-0-9613921-1-6},
  publisher = {Graphics Press},
  title = {{Envisioning Information}},
  year = 1990
}
@misc{Slyusarev2017,
  author = {Slyusarev, Sergey},
  title = {{MetaPost + ConTeXt rendition of Oliver Byrne's "The first six books of the Elements of Euclid"}},
  year = {2017},
  howpublished = {\url{https://github.com/jemmybutton/byrne-euclid}}
}
@misc{Rougeux2018,
  author = {Rougeux, Nicholas},
  title = {{Byrne’s Euclid}},
  year = {2018},
  howpublished = {\url{https://www.c82.net/euclid/}}
}
@misc{Okabe2008,
  author = {Okabe, Masataka and Ito, Kei},
  title = {{Color Universal Design (CUD) How to make figures and presentations that are friendly to Colorblind people}},
  year = {2008},
  howpublished = {\url{https://jfly.uni-koeln.de/color/}}
}
\end{filecontents}

\documentclass{ltxdoc}
\usepackage{byrne}
\usepackage{ccicons,bxtexlogo,listings,hyperref}
\hypersetup{
     colorlinks=true,
     linkcolor=blue,
     filecolor=blue,
     citecolor = black,      
     urlcolor=cyan,
     }

\lstset{
language=MetaPost,
alsolanguage=TeX,
numbers=none,
basicstyle=\ttfamily\scriptsize
}

\def\mpPre{textLabels := true;}

\author{Sergey Slyusarev}
\title{``Byrne'' v. 0.2.4 package for \METAPOST\ and \LaTeX}

\begin{document}
\maketitle

\begin{abstract}
This document describes ``Byrne'' package for \METAPOST\ and \LaTeX.
\end{abstract}

\begin{centering}

This document is distributed under CC-BY-SA 4.0 license 

\ccbysa 

\href{https://github.com/jemmybutton/byrne-latex}{https://github.com/jemmybutton/byrne-latex}

\end{centering}

\section{Introduction}
Oliver Byrne's \href{https://archive.org/details/firstsixbooksofe00byrn/}{1847 quirky edition on the first six books of Euclid's ``Elements''}\cite{Byrne1847} is an interesting example of tight interplay between text and graphics in information visualization. The main feature of this book is that instead of relying on letter designations to describe lines, angles, etc., all the diagrams in it are colored and parts of these diagrams are directly incorporated into text.

Recently this work met somewhat of a renaissance and in the span of a couple of years at least three independent attempts were made at reviving Byrne's work. In early 2017 the first six books \href{https://github.com/jemmybutton/byrne-euclid/}{remade in \ConTeXt} were published on GitHub\cite{Slyusarev2017}, in late 2018 an \href{https://www.c82.net/euclid/}{interactive web-version} was published by Nicholas Rougeux\cite{Rougeux2018} and in late 2019 a \href{https://www.kroneckerwallis.com/product/euclids-elements-completing-oliver-byrnes-work/}{printed version} of all Euclid's 15 books was published by Kronecker Wallis. All three are very different in terms of approach and goals.

The \ConTeXt\ version's main objective was to develop a toolkit for applying Byrne's approach to a variety of geometry problems in the least time-consuming manner. This package is a \LaTeX\ (specifically \LuaLaTeX) version of the toolkit. It consists of two parts: \METAPOST\ code to describe and render geometric constructions and \LaTeX\ code to incorporate these constructions in text.

\section{Requirements}

This package works with \LuaLaTeX\ and requires \texttt{luamplib v2.23.0} or higher.
\section{Example}

\begin{minipage}{\textwidth}
\vskip 0.5\baselineskip
\defineNewPicture{
textLabels := true;
angleSize := 1cm;
pair A, B, C;
A := (0, 0);
B := (0, 2cm);
C := (3cm, 0);
byAngleDefine(C, B, A, byyellow, 0);
byAngleDefine(B, A, C, byblue, 0);
byAngleDefine(A, C, B, byred, 0);
draw byNamedAngleResized();
byLineDefine(A, B, byred, 0, 0);    
byLineDefine(B, C, byblue, 0, 0);   
byLineDefine(C, A, byyellow, 0, 0); 
draw byNamedLineSeq(0)(AB,BC,CA);
draw byLabelsOnPolygon(A, B, C)(ALL_LABELS, 0);
}
~\hfill\drawCurrentPicture\hfill~
\vskip \baselineskip

In 
\drawFromCurrentPicture[middle][triangleABC]{
startAutoLabeling;
draw byNamedLineSeq(0)(AB,BC,CA);
stopAutoLabeling;
} 
the angle \drawAngle{A} 
is a right angle, therefore \triangleABC 
is a right-angled triangle. 
In it $\drawUnitLine{CB} > \drawUnitLine{AB}$ 
and $\drawUnitLine{BC} > \drawUnitLine{AC}$.
\end{minipage}

\vskip 2\baselineskip
The construction above is described like this:
\vskip 1.5\baselineskip

\begin{lstlisting}
\usepackage{byrne}
...
\defineNewPicture{ % MetaPost code to describe the main diagram is placed inside
  textLabels := true; % This turns text labels on
  pair A, B, C; 
  A := (0, 0);  
  B := (0, 2cm);
  C := (3cm, 0);
  byAngleDefine(C, B, A, byyellow, 0); % This defines a yellow angle CBA
  byAngleDefine(B, A, C, byblue, 0);   
  byAngleDefine(A, C, B, byred, 0);    
  draw byNamedAngleResized(); % Draws angles. 
  byLineDefine(A, B, byred, 0, 0);    % This defines a red line AB. 
  byLineDefine(B, C, byblue, 0, 0);   
  byLineDefine(C, A, byyellow, 0, 0); 
  draw byNamedLineSeq(1)(AB,BC,CA); % Draws joint lines in sequence
  draw byLabelsOnPolygon(A, B, C)(0, 0); % Draws text labels
}                                   
\drawCurrentPicture % Draws the diagram

In 
\drawFromCurrentPicture[middle][triangleABC]{ 
  startAutoLabeling;
  draw byNamedLineSeq(0)(AB,BC,CA);           
  stopAutoLabeling;
}
the angle \drawAngle{A} is a right angle, therefore \triangleABC\ is
a right-angled triangle. In it $\drawUnitLine{CB} > \drawUnitLine{AB}$ 
and $\drawUnitLine{BC} > \drawUnitLine{AC}$. 
\end{lstlisting}

\vskip 1.5\baselineskip

Several things to note here. 

In the \METAPOST\ part: 
All points are ordinary \METAPOST\ pairs and can be defined and manipulated as such. Normally every part of the diagram is first defined (e.g. \texttt{byAngleDefine} or \texttt{byLineDefine}) and then is drawn (e.g. \texttt{draw byNamedAngleResized...} or \texttt{draw byNamedLineSeq...}). Also, although Byrne didn't use text labels in his book, they are implemented in this package \ref{textlabels}. Normally they are placed semi-manually in the main diagram (using functions like \texttt{byLabelsOnPolygon}) and mostly automatically in offspring pictures. By default they are turned off, and to turn them on \texttt{textLabels := true;} should be set.

In the \LaTeX\ part: 
The most general way to reference main diagram is to use \cs{drawFromCurrentPicture}. It will process arbitrary \METAPOST\ code based on the main diagram's code and output an image. However, it would be too cumbersome to use this route every time, so a few shortcuts are in place. If you do need to process arbitrary code, you can give picture a name (in the example it's \texttt{triangleABC}). It will define a macro of the same name \cs{triangleABC} which will output the same image again. For most common cases there are special macros which don't require you to write any \METAPOST\ code. For instance \cs{drawAngle} and \cs{drawUnitLine} allow you to call angles and lines simply by name. The names don't have to match the initial definition exactly. For instance, the angle in the example can be called \texttt{A}, \texttt{BAC} or \texttt{ABC} interchangeably, or the same line segment can be called either \texttt{BC} or \texttt{CB}.

For more examples you can look at the source code of the \href{https://github.com/jemmybutton/byrne-euclid/}{\ConTeXt\ version of Byrne's book.} This package shares syntax with it and its code can be transferred to \LaTeX\ with minimal changes.

The following reference guide is not complete and will be updated in the future.

\section{\METAPOST\ part reference}

\subsection{Global variables and settings}

\subsubsection{Global variables}\label{Variables}
	
	There are several variables which control the looks and behaviour.
	
	\texttt{lineWidth}\label{lineWidth}~— the width for regular lines, set to \texttt{2pt} by default. Normally referenced as \texttt{0}.
	
	\texttt{lineWidthThin}~— the width for thin lines, set to \texttt{1pt} by default. Normally referenced as \texttt{1}.
	
	\texttt{lineWidthHair}~— the width for superthin lines, set to \texttt{1/2pt} by default. Normally referenced as \texttt{2}.
	
	\texttt{pointMarkSize}\label{pointMarkSize}~— size of point marks, set to \texttt{4pt} by default.
	
	\texttt{pointLinesSize}\label{pointLinesSize}~— size for line segments used to depict points, set to \texttt{1/2cm} by default.

	\texttt{defaultScaleFactor}~— global default scale factor, set to \texttt{1} by default.

	\texttt{angleSize}\label{angleSize}~— angle arc radius, set to \texttt{1cm} by default.
	
	\texttt{angleScale}\label{angleScale}~— scale factor for angle arcs, set to \texttt{1} by default.

	\texttt{globalRotation}~— angle to rotate the whole picture.

	\texttt{markLength}~— size of marks on lines, set to \texttt{3lineWidth} by default.

	\texttt{rayExtension}~— length for a ray depiction, set to \texttt{1/3cm} by default.

%	magnitudeSize := 5/18cm;
%	magnitudeScale := 1;
%	magnitudeGap := 3/2lineWidth;
	
	\texttt{textLabels}~— whether to render text labels, set to \texttt{false} by default.

%ghostLines := true;

	\texttt{autoRightAngles}\label{autoRightAngles}~— whether to depict right angles using angles instead of arcs, set to \texttt{false} by default.

%omitDuplicateTextLabels := false;
	
	\texttt{textLabelShift}~— how far away to put text labels from points, set to \texttt{lineWidth} by default.
	
%autoLabelingMode := false;
%mainPictureMode := false;

%pathToString

\subsubsection{defineColor.ColorName(color)}\label{defineColor}
	
	\defineNewPicture{
	textLabels := false;
	pair A, B, C;
	A := dir(60);
	B := (0, 0);
	C := dir(0);
	forsuffixes s=byblack,byred,byblue,byyellow,oiBlack,oiOrange,oiSkyBlue,oiGreen,oiYellow,oiBlue,oiVermillion,oiPurple:
		byAngleDefine.s(A, B, C,s, 0);
	endfor;
	}
	Defines a color. Colors can be defined as regular \METAPOST\ colors as well, this is just a shorthand version.

	\texttt{ColorName}~— mandatory color name of \texttt{suffix type}.
	
	\texttt{color}~— an actual calor, can be either of \texttt{color} type or of \texttt{cmykcolor} type.
	
	Some colors are predefined. Colors similar to the ones Byrne used for his book are: \texttt{byblack}\drawAngle{byblack}, \texttt{byred}\drawAngle{byred}, \texttt{byblue}\drawAngle{byblue}, \texttt{byyellow}\drawAngle{byyellow}. One obvious issue of any color coding is whether the colors are discernible by colorblind people. Byrne's colors should be mostly fine, but there are only foru of them. In case more colors are necessary, eight colors from \href{https://jfly.uni-koeln.de/color/}{colorblind-friendly palette by Okabe and Ito} \cite{Okabe2008} are defined: \texttt{oiBlack}\drawAngle{oiBlack}, \texttt{oiOrange}\drawAngle{oiOrange}, \texttt{oiSkyBlue}\drawAngle{oiSkyBlue}, \texttt{oiGreen}\drawAngle{oiGreen}, \texttt{oiYellow}\drawAngle{oiYellow}, \texttt{oiBlue}\drawAngle{oiBlue}, \texttt{oiVermillion}\drawAngle{oiVermillion}, \texttt{oiPurple}\drawAngle{oiPurple}. Also text labels \ref{textlabels} are helpful as a secondary means of identification.

%\subsubsection{selectOutlineColor.ColorName}\label{selectOutlineColor}
	
%	Selects an outline color for a color.

%	\texttt{ColorName}~— mandatory color name of \texttt{suffix type}.
	
% ...

\subsubsection{startTempScale(tmpScale); ... \METAPOST\ code ... stopTempScale;}\label{startTempScale}

	Used to temporarily set scale factor for a section of code;

	\texttt{tmpScale}~— scale factor for a section of code.
		
\subsubsection{startTempAngleScale(tmpAngleScale); ... \METAPOST\ code ... stopTempAngleScale;}\label{startTempAngleScale}

	Used to temporarily set angle scale factor for a section of code;

	\texttt{tmpAngleScale}~— angle scale factor for a section of code.

\subsubsection{startGlobalRotation(rotationAngle); ... \METAPOST\ code ... stopGlobalRotation;}\label{startGlobalRotation}

	Used to temporarily set global rotation for a section of code;

	\texttt{rotationAngle}~— global rotation for a section of code.
	
\subsubsection{startAutoLabeling; ... \METAPOST\ code ... stopAutoLabeling}\label{startAutoLabeling}

	Used to turn auto labeling for a section of code. Most of the drawing functions have auto labeling which is turned off by default. Sometimes it's handy to use it instead of labeling items by hand.

%startOffspringPictureMode
%stopOffspringPictureMode

%startMainPictureMode
%stopMainPictureMode

\subsection{Lines}

% byLineRender
% byReturnLineLength

\subsubsection{byLineDefine.LineName(A, B, color, dashed, thick)}\label{byLineDefine}

	Defines a straight line. Does not return anything.
	
	\texttt{LineName}~— optional line name of \texttt{suffix type}. If no name is provided, it is being constructed from point names, e.g. \texttt{AB}.
	
	\texttt{A, B}~— point names, of \texttt{suffix} type (i.e., variable names should be provided).
	
	\texttt{color}~— line color, of \texttt{color} type.
	
	\texttt{dashed}~— is line dashed. \texttt{0} for solid line and \texttt{1} for dashed line.
	
	\texttt{thick}~— is line thick. \texttt{0} for regular line and \texttt{1} for thin line \ref{lineWidth}.

	\defineNewPicture{
		pair A, B, C, D;
		A := (0, 0);
		B := (2cm, 0);
		C := (3cm, 0);
		D := (5cm, 0);
		byLineDefine(A, B, byred, 0, 0);
		byLineDefine(C, D, byblue, 1, 1);
	}
	For example, this line \drawUnitLine{AB} is defined as \texttt{byLineDefine(A, B, byred, 0, 0);} and this line \drawUnitLine{CD} is defined as \texttt{byLineDefine(C, D, byblue, 1, 1);}

% byLineStylize

\subsubsection{byLine.LineName(A, B, color, dashed, thick)}\label{byLine}

	Defines and draws a straight line. Returns a \texttt{picture} of the line.
	
	Arguments are the same as in \texttt{byLineDefine} \ref{byLineDefine}.

% byLineFull
% byLineWithName
% byNamedLineFull

\subsubsection{byNamedLine(LINES\_LIST)}\label{byNamedLine}

	Draws lines. Returns a picture of the lines.
	
	\texttt{LINES\_LIST}~— a comma-separated list of line names.

\subsubsection{byNamedLineSeq(lineShift)(LINES\_LIST)}\label{byNamedLineSeq}

	\defineNewPicture[1]{
		pair A, B, C;
		A :=  dir(45) scaled 1/4cm;
		B := (0, 0);
		C :=  dir(0) scaled 1/4cm;
		byLineDefine(A, B, byred, 0, 0);
		byLineDefine(B,C, byyellow, 0, 0);
		draw byNamedLineSeq(0)(BC,AB) scaled 2;
	}
		
	Draws lines joined in sequence. Line joints look like this:\drawCurrentPicture. Returns a picture of the lines.
	
	\texttt{lineShift}~— how much the lines are shifted perpendicular lines' axis. \texttt{1} is for one regular line thickness to one side%
	\drawFromCurrentPicture[bottom]{
	draw byNamedLineSeq(1)(BC,AB) scaled 2;
	draw (A--B--C) scaled 2 withpen pencircle scaled 1/2pt;
	}, 
	\texttt{-1} is for one regular line thickness to the other side%
	\drawFromCurrentPicture[bottom]{
		draw byNamedLineSeq(-1)(BC,AB) scaled 2;
		draw (A--B--C) scaled 2 withpen pencircle scaled 1/2pt;
	}.
	
	\texttt{LINES\_LIST}~— a comma-separated list of line names.
	

\subsubsection{byMarkLine(position, color)(LineName)}\label{byMarkLine}

	\defineNewPicture[1]{
		pair A, B;
		A := (0, 0);
		B := (1cm, 0);
		byLineDefine(A, B, byblue, 0, 0);
	}
	
	Defines and draws a mark on a line.
	
	\texttt{position}~— a position of the mark. \texttt{0} for one end of the line, \texttt{1} for the other end of the line.
	
	\texttt{color}~— mark color, of \texttt{color} type.
	
	\texttt{LineName}~— line name, of \texttt{suffix} type.
	
	For example this line mark \drawFromCurrentPicture{
		startAutoLabeling;
		draw byNamedLine(AB);
		draw byLabelLine(0)(AB);
		draw byMarkLine(1/4, byred, AB);
		stopAutoLabeling;
	} is drawn with \texttt{draw byMarkLine(1/4, byred, AB);}.

\subsubsection{byNamedMarkLine(LineName)}

	Draws a defined mark on the given line.
	
	\texttt{LineName}~— line name, of \texttt{suffix} type.
	
%byFindLinePointedThere
%byConstructCompoundLine
%byExpandLines
%byNamedCompoundLine
%byNamedCompoundRay
%byNamedCompoundIndLine
%byNamedCompoundLineRender
%generateLineSynonyms

\subsection{Points}

\subsubsection{byPointLabelDefine(A, pointLabel)}\label{byPointLabelDefine}

	Defines a point text label, returns nothing. By default point names are the same as the names of respective variables.
	
	\texttt{A}~— a name of a point of \texttt{suffix} type  (i.e., variable name should be provided).
	
	\texttt{pointLabel}~— point label of \texttt{string} type.

\subsubsection{byPointLabelRemove(POINTS\_LIST)}\label{byPointLabelRemove}

	Sets text labels of multiple points to blank. Useful if text labels are turned on, but you don't want labels on certain points.

	\texttt{POINTS\_LIST}~— a comma-separated list of point names.

\subsubsection{byPointMarkDefine(PointName)(color, style)}\label{byPointMarkDefine}

	\defineNewPicture{
		textLabels := false;
		pair A, B;
		A := (0, 0);
		B := (1cm, 0);
		draw byPointMark(A,  byblue, 0);
		draw byPointMark(B,  byred, 1);
	}
	
	Defines a point mark.

	\texttt{color}~— mark color, of \texttt{color} type.

	\texttt{style}~— \texttt{0} for solid circle \drawPointM{A}, \texttt{1} for white circle with outline \drawPointM{B}. Mark size is controlled by \texttt{pointMarkSize} \ref{pointMarkSize}.
		
%byPointXYZDefine
%byPointXYZEmpty
%byIsPointInSpace
%byPair
%byRotatePoints
%byPointMarkRender
%byNamedPointMark
%byPointMark
%byNamedPointLines

\subsection{Arcs and circles}

%byCirclePathGenerate
%byArcRender

\subsubsection{byArcDefineBE.ArcName(O, begin, end, radius, color, dashed, thick, shift, endType)}\label{byArcDefineBE}

	Defines an arc based on its center, radius and two angles. Returns nothing.

	\defineNewPicture[1]{
		textLabels := false;
		pair A, B;
		A := (0, 0);
	}
	
	\texttt{ArcName}~— optional arc name of \texttt{suffix type}. If no name is provided, it is being constructed from center point name, e.g. \texttt{O}.
	
	\texttt{O}~— the center of the circle an arc is from, of \texttt{suffix} type (i.e., variable name should be provided).
	
	\texttt{begin, end}~— beginning and ending of the arc in eighths (in essence, \texttt{arctime} of \texttt{fullcircle}). \texttt{0} for 3 o'clock, \texttt{2} for 12 o'clock etc. For instance, this
	\drawFromCurrentPicture{
		draw byArcBE(A, 0, 3, 2/6cm, byblue, 0, 0, 1, 0);
	}
	is \texttt{0, 3} and this
	\drawFromCurrentPicture{
		draw byArcBE(A, 5, 7, 2/6cm, byblue, 0, 0, 1, 0);
	}	
	is \texttt{5, 7}.
	
	\texttt{radius}~— arc radius.
	
	\texttt{color}~— arc color, of \texttt{color} type.
	
	\texttt{dashed}~— is arc line dashed. \texttt{0} for solid line and \texttt{1} for dashed line.
	
	\texttt{thick}~— is arc line thick. \texttt{0} for regular line and \texttt{1} for thin line \ref{lineWidth}.
	
	\texttt{shift}~— how much arc line is shifted. \texttt{1} is for one regular line thickness outwards
	\drawFromCurrentPicture{
		draw byArcBE(A, 1/2, 7/2, 1/6cm, byyellow, 0, 0, 1, 0) scaled 2;
		draw (subpath (1/2, 7/2) of (fullcircle scaled 4/6cm)) withpen pencircle scaled 1/2pt;
	}, \texttt{-1} is for one regular line thickness inwards
	\drawFromCurrentPicture{
		draw byArcBE(A, 1/2, 7/2, 1/6cm, byyellow, 0, 0, -1, 0) scaled 2;
		draw (subpath (1/2, 7/2) of (fullcircle scaled 4/6cm)) withpen pencircle scaled 1/2pt;
	}.
	
	\texttt{endType}~— type of arc line ends. \texttt{0} for ends cut by the radii
	\drawFromCurrentPicture{
		draw byArcBE(A, 1/2, 7/2, 1/6cm, byred, 0, 0, 0, 0) scaled 2;
	}
	and \texttt{1} for ends cut by the chord
	\drawFromCurrentPicture{
		draw byArcBE(A, 1/2, 7/2, 1/6cm, byred, 0, 0, 0, 1) scaled 2;
	}.

\subsubsection{byArcBE.arcName(O, begin, end, radius, color, dashed, thick, shift, endType)}\label{byArcBE}

	Defines and draws an arc based on its center, radius and two angles. Returns the picture of the arc.
	
	Arguments are the same as in \texttt{byArcDefineBE} \ref{byArcDefineBE}.

\subsubsection{byArcDefine.ArcName(O, B, E, radius, color, dashed, thick, shift, endType)}\label{byArcDefine}
	
	Defines an arc based on its center, radius and two points. Returns nothing.
	
	Arguments are the same as in \texttt{byArcDefineBE} \ref{byArcDefineBE}, except for instead of angles in eights points are used.
	
	\texttt{ArcName}~— optional arc name of \texttt{suffix type}. If no name is provided, it is being constructed from point names, e.g. \texttt{BOE}.
	
	\texttt{B, E}~— points in the direction of the beginning and the ending of the arc respectively. Of \texttt{suffix} type (i.e., variable names should be provided).

\subsubsection{byArc.ArcName(O, B, E, radius, color, dashed, thick, shift, endType))}\label{byArc}
	
	Arguments are the same as in \texttt{byArcDefine} \ref{byArcDefine}.
	
\subsubsection{byNamedArcExact(ARCS\_LIST)}\label{byNamedArcExact}
	Draws a picture of arcs just as they were defined. Returns a picture of the arcs.
	
	\texttt{ARCS\_LIST}~— a comma-separated list of arc names.
	
\subsubsection{byNamedArcSeq(arcShift)(ARCS\_LIST)}\label{byNamedArcSeq}

	Draws arcs joined in sequence (only affects dash patterns). Returns a picture of the arcs.
	
	\texttt{arcShift}~— how much the arcs are shifted outwards. \texttt{1} is for one regular line thickness outwards.
	
	\texttt{ARCS\_LIST}~— a comma-separated list of arc names.
	
\subsubsection{byNamedArc(ARCS\_LIST)}\label{byNamedArc}
	Draws a picture of arcs, except of it ignores \texttt{shift} and \texttt{endType}. Returns a picture of the arcs.
	
	\texttt{ARCS\_LIST}~— a comma-separated list of arc names.

%byNamedArcLabel

\subsubsection{byCircleDefineFree.CircleName(o, radius, color, dashed, thick, shift)}\label{byCircleDefineFree}
	
	Defines a circle based on its center and radius. Returns nothing.
	
	\defineNewPicture[1]{
	}
	
	\texttt{CircleName}~— optional circle name of \texttt{suffix type}. If no name is provided, \texttt{aCircle} is used for a name.
	
	\texttt{o}~— the center of the circle, of \texttt{pair} type.
	
	\texttt{radius}~— circle radius.
	
	\texttt{color}~— circle color, of \texttt{color} type.
	
	\texttt{dashed}~— is circle line dashed. \texttt{0} for solid line and \texttt{1} for dashed line.
	
	\texttt{thick}~— is circle line thick. \texttt{0} for regular line and \texttt{1} for thin line \ref{lineWidth}.
	
	\texttt{shift}~— how much circle line is shifted. \texttt{1} is for one regular line thickness outwards
	\drawFromCurrentPicture{
		byCircleDefineFree((0,0), 1/8cm, byyellow, 0, 0, 1);
		draw byNamedCircle(aCircle) scaled 2;
		draw fullcircle scaled 1/2cm;
	}, \texttt{-1} is for one regular line thickness inwards
	\drawFromCurrentPicture{
		byCircleDefineFree((0,0), 1/8cm, byyellow, 0, 0, -1);
		draw byNamedCircle(aCircle) scaled 2;
		draw fullcircle scaled 1/2cm;
	}.

\subsubsection{byCircleDefineR.CircleName(O, radius, color, dashed, thick, shift)}\label{byCircleDefineR}
	
	Defines a circle based on its center and radius. Returns nothing.
	
	Arguments are the same as in \texttt{byCircleDefineFree} \ref{byCircleDefineFree}, except for the center is not defined directly by a \texttt{pair}.
	
	\texttt{CircleName}~— optional circle name of \texttt{suffix type}. If no name is provided, it is being constructed from center name, e.g. \texttt{O}.
	
	\texttt{O}~— the center of the circle. Of \texttt{suffix} type (i.e., variable name should be provided).

\subsubsection{byCircleR.CircleName(O, radius, color, dashed, thick, shift)}\label{byCircleR}
	
	Defines and draws circle based on its center and radius. Returns a picture of that circle.
	
	Arguments are the same as in \texttt{byCircleDefineR} \ref{byCircleDefineR}.

\subsubsection{byCircleDefine.CircleName(O, A, color, dashed, thick, shift)}\label{byCircleDefine}
	
	Defines circle based on its center and a point. Returns nothing.
	
	Arguments are the same as in \texttt{byCircleDefineR} \ref{byCircleDefineR}, except for instead of the radius, a point through which the circle is drawn is used.
	
	\texttt{CircleName}~— optional circle name of \texttt{suffix type}. If no name is provided, it is being constructed from point names, e.g. \texttt{OA}.
	
	\texttt{A}~— a point through which the circle is drawn. Of \texttt{suffix} type (i.e., variable name should be provided).

\subsubsection{byCircle.CircleName(O, A, color, dashed, thick, shift)}\label{byCircle}
	
	Defines and draws circle based on its center and a point. Returns a picture of that circle.
	
	Arguments are the same as in \texttt{byCircleDefine} \ref{byCircleDefine}.

\subsubsection{byCircleABC.CircleName(A, B, C, color, dashed, thick, shift)}\label{byCircleABC}
	
	Arguments are the same as in \texttt{byCircleDefineR} \ref{byCircleDefineR}, except for instead of the center and the radius, three points through which the circle is drawn are used.
	
	\texttt{CircleName}~— optional circle name of \texttt{suffix type}. If no name is provided, it is being constructed from point names, e.g. \texttt{ABC}.
	
	\texttt{A, B, C}~— points through which the circle is drawn. Of \texttt{suffix} type (i.e., variable names should be provided).

%byFindCircleCenterABC
%byFindCircleCenterABCinSpace
%byReturnCircleCenter

\subsubsection{byNamedCircle(CIRCLES\_LIST)}\label{byNamedCircle}
	
	Draws circles. Returns a picture of the circles.
	
	\texttt{CIRCLES\_LIST}~— a comma-separated list of circle names.

\subsection{Arbitraty figures}

\subsubsection{byArbitraryFigureDefine.ArbitraryFigureName(figurePath, col\-or, dashed, thick)}\label{byArbitraryFigureDefine}
	
	Defines an arbitrary figure (basically, any path). Returns nothing.
	
	\texttt{ArbitraryFigureName}~— optional figure name of \texttt{suffix type}. If no name is provided, \texttt{anArbitraryFigure} is used for a name.
	
	\texttt{figurePath}~— figure path, of \texttt{path} type.
	
	\texttt{color}~— figure color, of \texttt{color} type.
	
	\texttt{dashed}~— is figure line dashed. \texttt{0} for solid line and \texttt{1} for dashed line.
	
	\texttt{thick}~— is figure line thick. \texttt{0} for regular line and \texttt{1} for thin line \ref{lineWidth}.

\subsubsection{byArbitraryFigure.ArbitraryFigureName(figurePath, color, dash\-ed, thick)}\label{byArbitraryFigure}

	Defines an arbitrary figure. Returns nothing.
	
	Arguments are the same as in \texttt{byArbitraryFigure} \ref{byArbitraryFigure}.

\subsubsection{byNamedArbitraryFigure(ARBITRARY\_FIGURES\_LIST)}\label{byNamedArbitraryFigure}

	Draws arbitrary figures. Returns a picture of the figures.
	
	\texttt{ARBITRARY\_FIGURES\_LIST}~— a comma-separated list of figure names.

%byArbitraryFigureRender
%byArbitraryCurveDefine
%byNamedArbitraryCurve
%byListToPath
%byArbitraryCurve

\subsection{Filled figures}

%byFilledCircleSegment
%byNamedFilledCircleSegment
%byFilledCircleSector
%byNamedFilledCircleSector

\subsubsection{byPolygonDefine.PolygonName(POINTS\_LIST)(Color)}\label{byPolygonDefine}

	Defines a polygon based on its vertex points. Returns nothing.
	
	\texttt{PolygonName}~— optional polygon name \texttt{suffix}.
	
	\texttt{POINTS\_LIST}~— a comma-separated list of point names.
	
	\texttt{Color}~— line color, of \texttt{suffix} type (i.e. a variable name should be provided).

%byPolygonPathFromList

\subsubsection{byPolygon.polygonName(POINTS\_LIST)(Color)}\label{byPolygon}

	Defines and draws a polygon based on its vertex points. Returns a picture of the polygon.
	
	Arguments are the same as in \texttt{byPolygonDefine} \ref{byPolygonDefine}.

%byPolygonName

\subsubsection{byNamedPolygon(POLYGONS\_LIST)}\label{byNamedPolygon}
	
	Draws polygons. Returns a picture of the polygons.
	
	\texttt{POLYGONS\_LIST}~— a comma-separated list of polygon names.

%byMergePolygons
%polygonCleanup

\subsection{Angles}

\subsubsection{byAngleDefine.AngleName(A, B, C, color, style)}\label{byAngleDefine}
	
	\defineNewPicture{
		textLabels := false;
		pair A, B, C, A', B', C', A'', B'', C'';
		A :=  dir(60);
		B := (0, 0);
		C :=  dir(0);
		A' := A shifted (1cm, 0);
		B' := B shifted (1cm, 0);
		C' := C shifted (1cm, 0);
		A'' := A shifted (2cm, 0);
		B'' := B shifted (2cm, 0);
		C'' := C shifted (2cm, 0);
		byAngleDefine(A, B, C, byred, 0);
		byAngleDefine(A', B', C', byred, 1);
		byAngleDefine(A'', B'', C'', byred, 2);
	}
	
	Defines an angle based on three points. Returns nothing.

	\texttt{AngleName}~— optional angle name \texttt{suffix}.
		
	\texttt{A, B, C}~— angle points. Of \texttt{suffix} type (i.e., variable names should be provided).
	
	\texttt{color}~— angle color, of \texttt{color} type.
	
	\texttt{style}~— angle arc style. \texttt{0} for solid filled sector \drawAngle{B}, \texttt{1} for arc \drawAngle{B'}, \texttt{2} for dashed arc \drawAngle{B''}. Default arc radius is determined by \texttt{angleSize} \ref{angleSize}. It can be temporarily changed using \texttt{angleScale} \ref{angleScale}. You can also define custom angle styles \ref{AngleStyles}. 
	
\subsubsection{byConsiderAngleRight(AngleName)}\label{byConsiderAngleRight}

	\defineNewPicture{
	textLabels := false;
	pair A, B, C, A', B', C';
	A := dir(60)*cm;
	B := (0, 0);
	C := dir(0)*cm;
	A' := A shifted (2cm, 0);
	B' := B shifted (2cm, 0);
	C' := C shifted (2cm, 0);
	byAngleDefine(A, B, C, byyellow, 0);
	byAngleDefine(A', B', C', byyellow, 0);
	byConsiderAngleRight(A'B'C');
	}
	Makes a defined angle look like an angle \drawAngle{A'B'C'} instead of a circle arc \drawAngle{ABC}, as right angles are often depicted. Useful if an angle is not actually right in the diagram, but is meant to be right or assumed to be right. To make all the right angles look like this automatically, you can set \texttt{autoRightAngles := true;}\ref{autoRightAngles}.
	
	\texttt{AngleName}~— name of the angle. 

%byConstructAngleArc
%byIsArcClockwise
%byFullCircleToPlane

\subsubsection{byAngle.AngleName(A, B, C, color, style)}\label{byAngle}

	Defines and draws an angle based on three points. Returns a picture of the angle.
	
	Arguments are the same as in \texttt{byAngleDefine} \ref{byAngleDefine}.

\subsubsection{byAngleDefineExtended.AngleName(A, B, C, color, style)(OPTIONAL\_COLORS\_LIST)}\label{byAngleDefineExtended}

	Defines an angle based on three points. Returns nothing.
	
	Arguments are the same as in \texttt{byAngleDefine} \ref{byAngleDefine}, except for using this function it's possible to define optional colors for an angle.
	
	\texttt{OPTIONAL\_COLORS\_LIST}~— a comma-separated list of optional color names. See \ref{AngleStyles} for details.
	
\subsubsection{byAngleExtended.AngleName(A, B, C, color, style)(OPTION\-AL\_COLORS\_LIST)}\label{byAngleExtended}

	Defines and draws an angle based on three points. Returns a picture of the angle.
	
	Arguments are the same as in \texttt{byAngleDefineExtended} \ref{byAngleDefineExtended}.

\subsubsection{byNamedAngle(ANGLES\_LIST)}\label{byNamedAngle}
	
	Draws angles. Returns a picture of the angles.
	
	\texttt{ANGLES\_LIST}~— a comma-separated list of polygon names.

%byNamedSolidAngle
%byProcessAnglesList
%byAngleMWhite
%byAngleMSolid
%byAngleMLine
%byAngleMThinLine
%byAngleMDashedLine
%byNamedAngleSidesFull
%byNamedAngleDummySides
%byNamedAngleSides
%byNamedAngleWithDummySides
%byNamedAngleResized
%generateAngleSynonyms
%sortPointAnglesList
%bySplitStringIntoAngles
%byConstructCompoundAngle
%twoRightAngles
%rightAngle
%byDefineGenericRightAngles

\subsubsection{Angle styles}\label{AngleStyles}

	It's possible to add custom angle styles. To do this, you first need to define a function, with a particular set of arguments and then include this function's name into a special list. As an example here's the function which describes a regular solid angle sector:
	
\begin{lstlisting}
vardef byAngleMSolid (expr angleArc, angleColor)(suffix AngleOptionalColors) =
    save p;
    path p;
    p := angleArc scaled (angleScale*angleSize);
    image(
        fill ((0, 0)--p--cycle) withcolor angleColor;
    )
enddef;
\end{lstlisting}

	Note the argument \texttt{AngleOptionalColors}. It is not used for solid angles and is not defined with \texttt{byAngleDefine}, but several optional colors can be defined using \texttt{byAngleDefineExtended} \ref{byAngleDefineExtended} and can be accessed using \texttt{AngleOptionalColors[0]}, \texttt{AngleOptionalColors[1]} etc.

	And here's how this angle style is included in the list:

\begin{lstlisting}
byAngleMacroName[0] := "byAngleMSolid";
\end{lstlisting}

	Here \texttt{0} is the value of \texttt{sty} argument used in \texttt{byAngleDefine} \ref{byAngleDefine} and such to call this particular angle style.
	
	As a more practical example, in Byrne's book, in a couple of places for some reason he chooses not to use ordinary arcs and sectors, but instead goes with unique angle designs. In order not to include these peculiarities into the main lib in the \ConTeXt\ version they were defined \textit{in situ}. Here's the definition from IV.III:

	\defineNewPicture{
		vardef byAngleMSectors (expr angleArc, angleColor)(suffix angleOptionalColors) =
		    save p;
		    path p[];
		    p1 := (subpath(0, arctime (1/3arclength(angleArc)) of angleArc) 
		    	of angleArc) 
		    	scaled (angleScale*angleSize);
		    p2 := (subpath(arctime (1/3arclength(angleArc)) 
		    	of angleArc, arctime(2/3arclength(angleArc)) of angleArc) of angleArc) 
		    	scaled (angleScale*angleSize);
		    p3 := (subpath(arctime (2/3arclength(angleArc)) 
		    	of angleArc, length(angleArc)) of angleArc) 
		    	scaled (angleScale*angleSize);
		    image(
		        fill ((0, 0)--p1--cycle) withcolor angleOptionalColors[0];
		        fill ((0, 0)--p2--cycle) withcolor angleColor;
		        fill ((0, 0)--p3--cycle) withcolor angleOptionalColors[1];
		    )
		enddef;
		byAngleMacroName[3] := "byAngleMSectors";
		textLabels := false;
		pair A, B, C;
		A :=  dir(45) scaled 1/4cm;
		B := (0, 0);
		C :=  dir(0) scaled 1/4cm;
		byAngleDefineExtended(A, B, C, byred, 3)(byblue, byyellow);
	}
	
\begin{lstlisting}	
vardef byAngleMSectors (expr angleArc, angleColor)(suffix angleOptionalColors) =
    save p;
    path p[];
    p1 := (subpath(0, arctime (1/3arclength(angleArc)) of angleArc) 
    	of angleArc) 
    	scaled (angleScale*angleSize);
    p2 := (subpath(arctime (1/3arclength(angleArc)) 
    	of angleArc, arctime(2/3arclength(angleArc)) of angleArc) of angleArc) 
    	scaled (angleScale*angleSize);
    p3 := (subpath(arctime (2/3arclength(angleArc)) 
    	of angleArc, length(angleArc)) of angleArc) 
    	scaled (angleScale*angleSize);
    image(
        fill ((0, 0)--p1--cycle) withcolor angleOptionalColors[0];
        fill ((0, 0)--p2--cycle) withcolor angleColor;
        fill ((0, 0)--p3--cycle) withcolor angleOptionalColors[1];
    )
enddef;
byAngleMacroName[3] := "byAngleMSectors";
\end{lstlisting}

This angle style employs two optional colors and can be called by setting \texttt{style} argument \ref{byAngleDefine} to \texttt{3}. This is what the result of \texttt{byAngleDefineExtended(A, B, C, byred, 3)(byblue, byyellow);} (\ref{byAngleDefineExtended}) looks like:\drawAngle{B}.
%https://archive.org/details/firstsixbooksofe00byrn/page/126/mode/2up

%\subsection{Arrows}

%commonArrowSettings
%byRotationArrowDefine
%byGenerateRotationArrowPath
%byNamedRotationArrow
%byFlatArrowDefine
%byNamedFlatArrow

%\subsection{Spheres}

%\subsection{Magnitudes}

%byMagnitudeSymbolDefine
%byNamedMagnitudeSymbol
%byMagnitudeDefine
%byNamedMagnitude

\subsection{Text labels}\label{textlabels}

There are no text labels in Byrne's book, but, as Edward Tufte points out in his 1990 book, adding small text labels can actually help speed recognition of geometric elements \cite{Tufte90}. It's not clear whether it's indeed the case for the reader, but at the very least text labels provide the author with the means of linking source code with the rendered pages. Several functions listed below allow for adding text labels very similar to the ones suggested by Tufte.

Text labels are turned off by default. As a result, simply adding code for text labels won't make them visible. They only appear when \texttt{textLabels := true;} is set in the beginning of a main picture or globally by defining \texttt{\textbackslash def\textbackslash\{...\} mpPre} \ref{defineNewPicture}. Text labels don't always have to be added manually, most elements can do auto labeling \ref{startAutoLabeling} which is intended to work with standalone angles, polygons, etc. 

%\subsubsection{byTextLabel(labelType, text, point, angle, distance)}\label{byTextLabel}
%Draws a text label. Returns a picture of the label.

\subsubsection{byLabelPoint(A, labelAngle, distance)}\label{byLabelPoint}
Draws a text label for a point. Returns a picture of the label.
	
	\texttt{A}~— the point to label, of \texttt{suffix} type (i.e., point name should be provided).
	
	\texttt{labelAngle}~— angle at which the label should be drawn in degrees.
	
	\texttt{distance}~— distance at which the label should be drawn in \texttt{textLabelShift} units.

\subsubsection{byLabelLine(distance)(LINES\_LIST)}\label{byLabelLine}
	
	Draws text labels for lines. Returns a picture of the labels.
	
	\texttt{distance}~— distance at which the labels should be drawn in \texttt{textLabelShift} units.
	
	\texttt{LINES\_LIST}~— a comma-separated list of line names.

\subsubsection{byLabelPolygon(distance)(POLYGONS\_LIST)}\label{byLabelPolygon}
	
	Draws text labels for polygons. Returns a picture of the labels.
	
	\texttt{distance}~— distance at which the labels should be drawn in \texttt{textLabelShift} units.
	
	\texttt{POLYGONS\_LIST}~— a comma-separated list of polygon names.

%byLabelCircle

\subsubsection{byLabelsOnCircle(POINTS\_LIST)(CircleName)}\label{byLabelsOnCircle}
	
	Draws text labels for points on a circle. Returns a picture of the labels.
	
	\texttt{POINTS\_LIST}~— a comma-separated list of point names.
	
	\texttt{CircleName}~— circle name of \texttt{suffix type}.

\subsubsection{byLabelsOnPolygon(POINTS\_LIST)(style, shift)}\label{byLabelsOnPolygon}
	
	Draws text labels for points on a polygon. Returns a picture of the labels.
	
	\defineNewPicture{
	pair A, B, C, D;
	D := (0, 0);
	C := (1cm, 0);
	B := (2cm, 0);
	A := (1/2cm, 1cm);
	byPolygonDefine(D, C, A)(byred);
	byPolygonDefine(C, B, A)(byyellow);
	}
	
	\texttt{POINTS\_LIST}~— a comma-separated list of point names.
	
	\texttt{style}~— specifies which points to omit. \texttt{0} to draw labels for all listed points
	\drawFromCurrentPicture{
	draw byNamedPolygon(DCA,CBA);
	draw byLabelsOnPolygon(A, B, C, D)(0, 0);
	}, \texttt{1} to draw labels for all listed points, except for the ones at straight angles
	\drawFromCurrentPicture{
	draw byNamedPolygon(DCA,CBA);
	draw byLabelsOnPolygon(A, B, C, D)(1, 0);
	}, \texttt{2} omits first and last points
	\drawFromCurrentPicture{
	draw byNamedPolygon(DCA,CBA);
	draw byLabelsOnPolygon(A, B, C, D)(2, 0);
	}, \texttt{3} omits the first point
	\drawFromCurrentPicture{
	draw byNamedPolygon(DCA,CBA);
	draw byLabelsOnPolygon(A, B, C, D)(3, 0);
	}, \texttt{4} omits the last point
	\drawFromCurrentPicture{
	draw byNamedPolygon(DCA,CBA);
	draw byLabelsOnPolygon(A, B, C, D)(4, 0);
	}.
	
	\texttt{shift}~— negative to move labels closer, positive to move labels farther.

\subsubsection{byLabelLineEnd(A, B)(distance)}\label{byLabelLineEnd}
	
	Draws a text label for a line end. Returns a picture of the label.
	
	\texttt{A, B}~— line ends, of \texttt{suffix} type (i.e., point name should be provided).
	
	\texttt{distance}~— negative to move labels closer, positive to move labels farther.

%byLabelAngleCompensate

\section{\LaTeX\ part reference}

\subsection{General purpose}

\sloppy

\subsubsection{\textbackslash defineNewPicture [offspringPicture\-Sca\-leFactor] [mainPicture\-Sca\-le\-Factor] \{\METAPOST\ code\}}\label{defineNewPicture}

\fussy 

	This macro is used to describe a main diagram.

	\texttt{offspringPictureScaleFactor}~— how much smaller offspring pictures should be. \texttt{1/3} by default.
	
	\texttt{mainPictureScaleFactor}~— scale factor for the main picture. \texttt{1} by default.
	
	\texttt{\METAPOST\ code}~— actual \METAPOST\ code to describe the main picture. To have some snippets of code always executed before and after the code for the main picture (e.g. to turn on text labels by default with \texttt{textLabels := true;}), define \cs{mpPre} and \cs{mpPost} macros respectively in the preamble of your document, like this:
	
\begin{lstlisting}
\def\mpPre{...some \METAPOST\ code...}
\def\mpPost{...some \METAPOST\ code...}
\end{lstlisting}


\subsubsection{\textbackslash drawCurrentPicture}
	
	Draws the main diagram.

% \drawImageFromCurrentInstance

% \unmarkPictAsReady

% \addToUndefineList

\sloppy

\subsubsection{\textbackslash defineFromCurrentPicture \{verticalAlignment\} \{PictureName\} \{\METAPOST\ code\}}

\fussy

	This macro is used to describe a diagram, based on the main diagram.

	\texttt{verticalAlignment}~— vertical alignment declaration. \texttt{middle} to align the picture with the middle of the line, anything else for bottom alignment.

	\texttt{PictureName}~— picture name.

	\texttt{MP code}~— actual \METAPOST\ code to describe the picture.
	
	Can be drawn using \texttt{\textbackslash PictureName}.
	
\sloppy

\subsubsection{\textbackslash drawFromCurrentPicture [verticalAlignment] [PictureName] \{\METAPOST\nolinebreak\ code\}}
 
 \fussy
  
	This macro is used to describe and draw a diagram, based on the main diagram.

	\texttt{verticalAlignment}~— optional vertical alignment declaration. \texttt{middle} to align the picture with the middle of the line, anything else for bottom alignment.

	\texttt{PictureName}~— optional picture name.

	\texttt{\METAPOST\ code}~— actual \METAPOST\ code to describe the picture.
	
	Can be drawn again later using \texttt{\textbackslash PictureName}.

% \drawDefinedPicture

\subsection{Specialized}

\subsubsection{\textbackslash drawUnitLine[LineSecondName]\{LineName\}}

	Draws a line of unit length with colors and labels based on the line of the same name in the main diagram.

	\texttt{LineSecondName}~— optional line name.
	
	\texttt{LineName}~— name of the line to reference in the main diagram. 

	If a name is given, can be called later using \texttt{\textbackslash ulineLineNameLineSecondName}, otherwise~— \texttt{\textbackslash ulineLineName}. 

\subsubsection{\textbackslash drawProportionalLine\{LineName\}}

	Draws a line with colors and labels based on and length linearly proportional to the line of the same name in the main diagram.

	\texttt{LineName}~— name of the line to reference in the main diagram. 
	
	Can be called later using \texttt{\textbackslash plineLineName}.

%\drawProportionalLine

\subsubsection{\textbackslash drawSizedLine[LineSecondName]\{LineName\}}

	Draws a line with colors and labels based on and length proportional to the line of the same name in the main diagram.

	\texttt{LineSecondName}~— optional line name. 
	
	\texttt{LineName}~— name of the line to reference in the main diagram. 
	
	If a name is given, can be called later using \texttt{\textbackslash slineLineNameLineSecondName}, otherwise~— \texttt{\textbackslash slineLineName}. 

\subsubsection{\textbackslash drawUnitRay[RayName]\{LineName\}}

	Draws a ray of unit length with colors and labels based on the line of the same name in the main diagram.

	\texttt{RayName}~— optional ray name.
	
	\texttt{LineName}~— name of the line to reference in the main diagram. 

	If a name is given, can be called later using \texttt{\textbackslash urayLineNameRayName}, otherwise~— \texttt{\textbackslash urayLineName}. 

%\subsubsection{\textbackslash drawProportionalRay\{LineName\}}

%	Draws a ray.

%	\texttt{LineName}~— name of the line to reference in the main diagram. 
	
%	Can be called later using \texttt{\textbackslash prayAngleName}.

%\drawSizedRay

%\drawUnitIndLine

%\drawProportionalIndLine

\subsubsection{\textbackslash drawRightAngle, \textbackslash drawTwoRightAngles}
	\defineNewPicture{textLabels := false;}
	Draws a right angle \drawRightAngle\ and two right angles \drawTwoRightAngles\ respectively. 
	
	More broadly, following generic right angles are defined: \texttt{rightAngleNE} \drawAngle{rightAngleNE},  \texttt{rightAngleES} \drawAngle{rightAngleES},  \texttt{rightAngleSW} \drawAngle{rightAngleSW},  \texttt{rightAngleWN} \drawAngle{rightAngleWN}. 
	
	If you choose to go with angles instead of arcs for right angles (\ref{autoRightAngles}, \ref{byConsiderAngleRight}), adding \texttt{autoRightAngles := true;} to \texttt{\textbackslash mpPre} \ref{defineNewPicture} won't change the appearance of these angles, since they are defined before \texttt{\textbackslash mpPre} commands are executed. Instead, these angles should be redefined. There's a special command for this purpose: \texttt{byDefineGenericRightAngles(true);} where \texttt{true} tells this command to run \texttt{byConsiderAngleRight} \ref{byConsiderAngleRight} for each of the generic right angles.

\subsubsection{\textbackslash drawAngle\{AngleName\}}\label{drawAngle}

	Draws an angle.
	
	\defineNewPicture{
	pair A, B, C, D, E, O;
	O := (0, 0);
	A := (2cm, 0);
	B := A rotated (360/5);
	C := B rotated (360/5);
	D := C rotated (360/5);
	E := D rotated (360/5);
	byAngleDefine(A, O, B, byred, 0);
	byAngleDefine(B, O, C, byyellow, 0);
	byAngleDefine(C, O, D, byblue, 0);
	byAngleDefine(D, O, E, byblack, 0);
	byAngleDefine(E, O, A, byblack, 1);
	byLineDefine(A, O, byblack, 0, 0);
	}

	\texttt{AngleName}~— name of the angle to reference in the main diagram. 
	When just one letter is used, all the angles defined at this point will be drawn, e.g. \drawAngle{O}. When used to reference one single defined angle, the direction doesn't matter. 
	E.g. \texttt{AOB} and \texttt{BOA} will return the same picture \drawAngle{AOB}. 
	When used to reference an angle composed of several defined angles, the name sould be given counterclockwise. 
	E.g. \texttt{\textbackslash drawAngle\{AOD\}} is \drawAngle{AOD} and \texttt{\textbackslash drawAngle\{DOA\}} is \drawAngle{DOA}.
	
	Can be called later using \texttt{\textbackslash angleAngleName}.
	
\subsubsection{\textbackslash drawAngleWithSides \{AngleName\}}

	\defineNewPicture{
	pair A, B, C, D;
	A := (1/2cm, 2cm);
	B := (0, 0);
	C := (3cm, 0);
	D := 1/2[A, C];
	byAngleDefine(A, B, D, byyellow, 1);
	byAngleDefine(D, B, C, byyellow, 0);
	byLineDefine(A, B, byred, 1, 0);
	byLineDefine(B, C, byblue, 0, 0);
	draw byNamedAngleResized();
	draw byNamedLineSeq(0)(AB, BC);
	} 

	Draws an angle and sections of its adjacent sides placed if angle portion style is not \texttt{0}. E.g., this angle \drawAngle{B} is drawn with \texttt{\textbackslash drawAngle\{B\}}, and this angle \drawAngleWithSides{B} is drawn with \texttt{\textbackslash drawAngleWithSides\{B\}}. 

	\texttt{AngleName}~— the same as in \ref{drawAngle}.
	
	Can be called later using \texttt{\textbackslash anglewithsidesAngleName}.
	
\subsubsection{\textbackslash drawPolygon[verticalAlignment][PolygonNewName] \{Poly\-gon\-Na\-me\}}

	Draws a polygon.

	\texttt{verticalAlignment}~— optional vertical alignment declaration. \texttt{middle} to align the picture with the middle of the line, anything else for bottom alignment.

	\texttt{PolygonNewName}~— optional polygon name. 
	
	\texttt{PolygonName}~— name of the polygon to reference in the main diagram. 
	
	If a name is given, can be called later using \texttt{\textbackslash PolygonNewName}, otherwise~— \texttt{\textbackslash polygonPolygonName}. 
	
\subsubsection{\textbackslash drawCircle[verticalAlignment][scaleFactor]\{CircleName\}}

	Draws a circle.

	\texttt{verticalAlignment}~— optional vertical alignment declaration. \texttt{middle} to align the picture with the middle of the line, anything else for bottom alignment.
	
	\texttt{scaleFactor}~— optional scale factor for the circle to replace the default offspring picture scale factor. 
	
	\texttt{CircleName}~— name of the circle to reference in the main diagram. 
	
	Can be called later using \texttt{\textbackslash circleCircleName}.
	
\subsubsection{\textbackslash drawArc[verticalAlignment][scaleFactor]\{ArcName\}}

	Draws an arc.

	\texttt{verticalAlignment}~— optional vertical alignment declaration. \texttt{middle} to align the picture with the middle of the line, anything else for bottom alignment.
	
	\texttt{scaleFactor}~— optional scale factor for the arc to replace the default offspring picture scale factor. 
	
	\texttt{ArcName}~— name of the arc to reference in the main diagram. 
	
	Can be called later using \texttt{\textbackslash arcCircleName}.
	
\subsubsection{\textbackslash drawLine[verticalAlignment][LineNewName]\{LineName\}}

	Draws a line.

	\texttt{verticalAlignment}~— optional vertical alignment declaration. \texttt{middle} to align the picture with the middle of the line, anything else for bottom alignment.
	
	\texttt{LineNewName}~— optional line name. 
	
	\texttt{LineName}~— name of the line to reference in the main diagram. 
	
	If a name is given, can be called later using \texttt{\textbackslash LineNewName}, otherwise~— \texttt{\textbackslash lineLineName}. 
	
\subsubsection{\textbackslash drawPointM\{PointName\}}

	\defineNewPicture{
	pair A, B, C, D;
	A := (0, 0);
	B := dir(15)*cm;
	C := B rotated 120;
	D := C rotated 120;
	byLineDefine(A, B, byred, 0, 0);
	byLineDefine(A, C, byyellow, 0, 0);
	byLineDefine(A, D, byblue, 0, 0);
	draw byNamedLine(AD);
	draw byNamedLineSeq(0)(AB,AC);
	draw byPointMark(A,  byblack, 1);
	}	

	Draws a point, depicted as a small circle \drawPointM{A}.
	
	\texttt{PointName}~— name of the point to reference in the main diagram. 
	
	Can be called later using \texttt{\textbackslash pointmPointName}. 

\subsubsection{\textbackslash drawPointL[verticalAlignment][LinesToOmit]\{PointName\}}\label{drawPointL}

	Draws a point, depicted as line segments starting/ending in it \drawPointL{A}. Only the lines which were actually drawn, not just defined, are used. Line segments' length is controlled by \texttt{pointLinesSize} \ref{pointLinesSize}.

	\texttt{verticalAlignment}~— optional vertical alignment declaration. \texttt{middle} to align the picture with the middle of the line, anything else for bottom alignment.
	
	\texttt{LinesToOmit}~— a comma-separated list lines, segments of which not to draw. 
	
	\texttt{PointName}~— name of the point to reference in the main diagram. 
	
	If a list of lines to omit is given, can be called later using \texttt{\textbackslash pointl\-Point\-Name\-Minus\-Lines\-To\-Omit}, otherwise~— \texttt{\textbackslash pointlPointName}. 

\subsubsection{\textbackslash drawPoint[verticalAlignment][LinesToOmit]\{PointName\}}

	Draws a point, depicted as line segments starting/ending in it with a point mark if defined \drawPoint{A}. Only the lines which were actually drawn, not just defined, are used.

	Arguments are the same as in \texttt{drawPointL} \ref{drawPointL}.
	
	If a list of lines to omit is given, can be called later using \texttt{\textbackslash point\-Point\-Name\-Minus\-Lines\-To\-Omit}, otherwise~— \texttt{\textbackslash pointPointName}. 

%\drawMagnitude

\bibliographystyle{plain}
\bibliography{byrne-latex}

\end{document}